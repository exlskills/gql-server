export function RNG(seed) {
  // LCG using GCC's constants
  this.m = 0x80000000; // 2**31;
  this.a = 1103515245;
  this.c = 12345;

  this.state = seed ? seed : Math.floor(Math.random() * (this.m - 1));
}
RNG.prototype.nextInt = function() {
  this.state = (this.a * this.state + this.c) % this.m;
  return this.state;
};
RNG.prototype.nextFloat = function() {
  // returns in range [0,1]
  return this.nextInt() / (this.m - 1);
};
RNG.prototype.nextRange = function(start, end) {
  // returns in range [start, end): including start, excluding end
  // can't modulu nextInt because of weak randomness in lower bits
  let rangeSize = end - start;
  let randomUnder1 = this.nextInt() / this.m;
  return start + Math.floor(randomUnder1 * rangeSize);
};
RNG.prototype.choice = function(array) {
  return array[this.nextRange(0, array.length)];
};

export function shuffleArray(array, seed) {
  let shuffled = [...array];
  let rng = new RNG(seed);

  for (let i = shuffled.length - 1; i > 1; i--) {
    let r = Math.floor(rng.nextFloat() * i);
    let t = shuffled[i];
    shuffled[i] = shuffled[r];
    shuffled[r] = t;
  }
  return shuffled;
}

export function make_random_string() {
  let text = '';
  let possible = '0123456789';

  for (let i = 0; i < 5; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }

  return text;
}

export function getRandomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
}
